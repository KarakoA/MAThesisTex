\section{Project Structure and Overview}
The application is written mostly in TypeScript using npm as a package manager and Node.js as a runtime environment. 




%TODO eslint only js thats why no ts. at intro probably
Notable dependencies are TypeScript, for stricter syntax and types, lodash\parencite{lodash} for enrichening of collections, graphlib\parencite{graphlib} for the interaction diagrams graph,  babel\parencite{babel} as a transcompiler, eslint\parencite{eslintMainPage}, estree\parencite{estreeASTSpec} and eslint-plugin-vue\parencite{eslint_vue_parser} for parsing Vue.js code, d3-graphviz\parencite{graph_viz} in comination with light-server\parencite{light_server} for visualization of the generated interaction diagrams. The full list of dependencies can be found in the \code{package.json} of the project.
%TODO cite all of those directly?

%lint, ci, tests, etc? gith?

\subsection{Project structure}
%TODO define lang
The main source files of the project and their tests are included in the \code{src} directory and structured in several packages, each corresponding to a step in the process, except common, which is shared among all steps. Each will be described in more detail in the following sections.
Each package includes a models directory, which inludes the data types defined and used in this section.
The \code{web} directory contains code used to view the resulting diagram in the browser.
The \code{scripts} directory includes helper bash scripts, \code{results} holds snapshots of the results throughout development (with the latest being the current) and \code{resources} hold various additional files needed.
\begin{lstlisting}
  root:.
  |-- resources
  |   |-- output
  |
  |-- results
  |
  |-- scripts
  |
  |-- src
  |   |-- common
  |   |   |-- models
  |   |
  |   |-- main.ts
  |   |
  |   |-- generator
  |   |   |-- models
  |   |
  |   |-- parsing
  |   |   |-- builders
  |   |   |-- models
  |   |   |-- visitors
  |   |
  |   |-- scenarios
  |
  |-- web
\end{lstlisting}

\section{Parsing Vue.js}

Instead of implementing a parser, which directly outputs the simplfied Vue.js \gls{ast} described in \ref{ast} the capabilities of \textcite{eslintMainPage}  %TODO add cit
and \parencite{eslint_vue_parser} were used. 
The source files, which handle the parsing reside in the \code{parsing} directory.
The \code{ESLinter} class provides a wrapper around the Node.js API of ESlint. Custom visitors are implemented in order to extract the necessary nodes from the \gls{ast} of ESLint. Each visitor has a matching file in \code{models}, which holds the models specific to that visitor, and a \code{builder}, which keeps track of the visited nodes and builds the result data type. There are a total of three visitors - one for top level properties, another for bindings and the last one for method defintions, computed properties and the created method.
 
\subsection{Common Data Types}
Below are the common data types used by all visitors.
\begin{lstlisting}
export type Identifier = This | NameIdentifier | NumericIndex 
| GenericIndex;

interface BaseIdentifier {
  readonly name: string;
}
export interface This extends BaseIdentifier {
  name: "this";
  discriminator: IdentifierType.THIS;
}
export interface NumericIndex extends BaseIdentifier {
  discriminator: IdentifierType.NUMERIC_INDEX;
}
export interface GenericIndex extends BaseIdentifier {
  discriminator: IdentifierType.GENERIC_INDEX;
}
export interface NameIdentifier extends BaseIdentifier {
  discriminator: IdentifierType.NAME_IDENTIFIER;
}
\end{lstlisting}

%TODO lang
\begin{lstlisting} 
export type Entity = Method | Property;

export interface Property {
  id: Identifiers;
  discriminator: EntityType.PROPERTY;
}
export interface Method {
  id: Identifiers;
  args: ReadonlyArray<Entity>;
  discriminator: EntityType.METHOD;
}
\end{lstlisting}
Discriminators are used to be able to diferentiate between the types using type guards. The enums themselves are omitted here (\code{IdentifierType}, \code{EntityType}). The definitions here are not exactly the same as in the \gls{ast} \ref{ast} - some constraints are omitted, such as method names having to end on a a \code{NameIdentifier}. This will be given, since the parsed code would be invalid javascript otherwise.
\subsection{Top Level Properties}
The result of the top level properties has the following data type.
\begin{lstlisting}
export type TopLevelProperties = Array<Property>;

export interface TopLevelPropertiesResult {
  topLevel: TopLevelProperties;
}
\end{lstlisting}

The top level properties visitor is the simplest of all since it only reacts to the top level \code{data} node inside the \code{script} object  of the Vue.js \gls{spa}, which is a \code{ObjectExpression} \ref{eslint:object_expression}. It can be selected via the following selector:

%TODO lang
\label{impl:top_level_select}
\begin{lstlisting}

"ExportDefaultDeclaration > ObjectExpression > 
Property[key.name = data] ReturnStatement > ObjectExpression"(node){
  ...
}
\end{lstlisting}
In natural language the selector reads: "Select ObjectExpression nodes, which have a direct parent ReturnStatement, that has an indirect parent Property with a property \code{key.name} equal to \code{data} and a direct parent ObjectExpression with a direct parent ExportDefaultDeclaration.

For each of the properties \ref{eslint:property} of the \code{ObjectExpression} the name of the key (identifier) is stored. If the property is an object (value of \code{ObjectExpression} \ref{eslint:object_expression}) it is concatenated with the previously obtained key. Finally all obtained properties are prefixed with 'this'.

\subsection{Bindings}
The result of the bindings visitor has the following data type.
\begin{lstlisting}
  export enum BindingType {
    EVENT = "event", ONE_WAY = "one-way", TWO_WAY = "two-way",
  }
  
  export interface Tag {
    id: string;
    loc: Location;
    name: string;
    position?: string;
  }
  
  export interface BindingValue {
    item: Entity;
    bindingType: BindingType;
  }
  
  export type Binding = { tag: Tag; values: BindingValue[] };
  export interface BindingsResult {
    bindings: Binding[];
  }
\end{lstlisting}

The ESlint \gls{ast} nodes, which are interesting when parsing the bindings are \code{VElement} \ref{eslint:velement}, 
\code{Identifier} \ref{eslint:identifier}, \code{MemberExpression} \ref{eslint:member_expression} and \code{CallExpression} \ref{eslint:call_expression}. 

A \astnode{identifier} \ref{ast}, abstracted
in \code[]{common/identifier.ts}  can be a single \code{Identifier} or a \code{MemberExpression}, which can contain other \code{Identifier} nodes or \code{MemberExpression} nodes. Property Identifiers are extracted by finding the root \code{MemberExpression} or \code{Identifier} and traversing it. It is easy to determine if a \code{MemberExpression} or \code{Identifier} is the root - its parent is anything but a \code{MemberExpression}.

A \code{CallExpression} contains information about the name of the method and the arguments it has been called with, both in the form of nested \code{MemberExpression} and \code{CallExpression} nodes. Once again, only the root \code{CallExpression} node is extracted and converted to a \astnode{calledMethod} \ref{ast}, abstracted in the \code{Method} interface in \code{shared.ts}.

\code{VElement} nodes represent any HTML tag, matching a \astnode{tag} \ref{ast} abstracted in the \code{Tag} interface in code{template-bindings.ts} and contain information about the location of the tag and potentially a \code{VText} \ref{eslint:vtext} node, which will be set as its name if it is present. If not present, the name of the tag is equal to the name of the first binding. Therefore, information about tags is extracted once a \code{VELement} is exited, since all bindings will be known at this point.

Further, the binding type has to be determined. This can be extracted based on the \code{VAttribute} \ref{eslint:VAttribute}. Event bindings have a \code{VAttribute} with a \code{key.name.name} equal to 'on', two-way bindings equal to 'model' and everything else is interpreted as one-way bindings. This includes moustache statements, \code{v-bind}, \code{v-if} bindings and all other except \code{v-for} statements. This filter be achieved via the powerful \code{:not} in combination with \code{:matches} selectors: 
%TODO lang
\begin{lstlisting}
:not(:matches(
  VAttribute[key.name.name=on], 
  VAttribute[key.name.name=model],
  VAttribute[key.argument.name=key],
  VAttribute[key.name.name=for]))
\end{lstlisting}

With all the above, for example to match all two-way bindings and pass them on to the builder can be done via 
\begin{lstlisting}
  
"VAttribute[key.name.name=model] > VExpressionContainer
:matches(MemberExpression, Identifier, CallExpression)"(
  node) {
  if (utils.isRootNameOrCallExpression(node) && 
  utils.notArgument(node))
    builder.identifierOrExpressionNew(node, BindingType.TWO_WAY);
},
\end{lstlisting}

%TODO note why not args - method knows exactly what part

Bindings also need to substitute \code{v-for} statements. This is done by substituting the left side of the \code{v-for} statement with its right side and a generic index in all bindings that use it.

\subsection{Method Definitions}

\begin{lstlisting}
export interface MethodDefinition {
  id: Identifiers;
  args: ReadonlyArray<Property>;
  reads: ReadonlyArray<Property>;
  writes: ReadonlyArray<Property>;
  calls: ReadonlyArray<Method>;
}
export type MethodDefinitions = Array<MethodDefinition>;

export interface MethodsResult {
  init?: MethodDefinition;
  computed: MethodDefinitions;
  methods: MethodDefinitions;
}
\end{lstlisting}
All method definition like structures (computed properties, created) and methods are parsed by the visitor defined in \code{methods.js}.
Analogous to how the top level \code{data} object is selected \ref{impl:top_level_select}, the \code{methods}, \code{created} and \code{computed} objects can be selected. 
The name of the method including its arguments can be extracted from by \code{Property[value.type=FunctionExpression]} nodes. Using this information, one can have three selectors, one of each type, to determine what is being defined. For example for regular methods:
 
\begin{lstlisting}

"ExportDefaultDeclaration > ObjectExpression > Property
[key.name = methods] Property[value.type=FunctionExpression]"(node) {
  builder.newMethod(node, MethodType.METHOD);
},
\end{lstlisting}

Further the properties read, written and methods called need to be extracted. Methods called can be obtained by selecting \code{CallExpression} nodes. Properties written to can be obtained from the left side of a \code{AssignmentExpression} \ref{eslint:AssignmentExpression}.
There does not seem be an easy way to select all properties read from. Therefore all accesed identifiers are first stored and everything except reads, that can have an identifier (object properties, variable declarations, variables written to and names of called methods) is subtracted from it, in order to obtain the variables that the method reads from.

The following code can be used to obtain all variables written to by the current method-like in scope. 
\begin{lstlisting}
"ExportDefaultDeclaration > ObjectExpression > 
:matches(Property[key.name = methods], Property[key.name = created],
Property[key.name = computed]) AssignmentExpression"(node) {
  builder.identifierOrExpressionNew(node.left, AccessType.WRITES);
},
\end{lstlisting}
\subsection{Output}
Combinging all of the above, the following data structure is output.
\begin{lstlisting}
export class Result {
  fileName: string;
  topLevel: TopLevelPropertiesResult;
  methods: MethodsResult;
  bindings: BindingsResult;
  ...
}
\end{lstlisting}
\label{impl:result}
\section{Interaction Diagram Generation}
The generation of the interaction diagram graph from the result class from \ref{impl:result} is done in the \code{Transformer} class. 

The resolution of methods is abstracted in the \code{MethodResolver} class. It produces a 
\code{ResolvedMethodDefintition} for each called method in bindings and the initial method. In order to prevent duplicate resolution of methods and wasting of resources a \code{MethodCache} is introduced. The \code{Transformer} does not use the \code{MethodResolver} directly, but instead accesses it via the \code{MethodCache}. The cache includes directly called (bound to) and indirectly called (calls of methods), for each of which vertices will have to be created. 
Each \code{ResolvedMethodDefintition} has the following data type:
\begin{lstlisting}
export enum GeneralisedArgument {
  METHOD = "method",OTHER = "other",
}
export type ResolvedArgument =
  | Property | GeneralisedArgument.METHOD | GeneralisedArgument.OTHER;
export interface ResolvedMethodDefintition {
  id: Identifiers;
  args: ReadonlyArray<ResolvedArgument>;
  reads: ReadonlyArray<Property>;
  writes: ReadonlyArray<Property>;
  calls: ReadonlyArray<CalledMethod>;
}
export interface CalledMethod {
  id: Identifiers;
  args: ReadonlyArray<ResolvedArgument>;
}
\end{lstlisting}


As the underlying structure for the graph graphlib is used and wrapped in an own class - \code{ExtendedGraph}. It creates vertices on a 'create if not exist' basis by first looking up to see if the vertex exists in the graph, and if it does, does not add it again. Presence of edges is not checked, if an edge is added again, the previous one is simply overwritten. There can only be one edge per direction between two nodes, since no multigraph is used. Nodes and Edges in the graph have the following structure, as specified in \ref{concept:interaction_diagram_structure}:

%TODO format
\begin{lstlisting}
export enum EdgeType {
  SIMPLE = "simple", EVENT = "event", CALLS = "calls",
}
export interface Edge {
  source: Node;
  sink: Node;
  label: EdgeType;
}
\end{lstlisting}
\begin{lstlisting}
export enum NodeType {
  TAG = "tag",  DATA = "data", METHOD = "method", INIT = "init",
}

export type Node = TagNode | DataNode | MethodNode | InitNode;
interface BaseNode {
  id: string;
  name: string;
}
export interface TagNode extends BaseNode {
  loc: Location;
  discriminator: NodeType.TAG;
}
export interface MethodNode extends BaseNode {
  discriminator: NodeType.METHOD;
}
export interface InitNode extends BaseNode {
  discriminator: NodeType.INIT;
}
export interface DataNode extends BaseNode {
  parent?: string;
  type: IdentifierType;
  discriminator: NodeType.DATA;
}
\end{lstlisting}


The algorithm for generating the interaction diagrams graph as described in \ref{concept:algorithm_create_diagrams}
is implemented in the \code{Transformer} class.

First the init method is resolved by querying the \code{MethodCache} and afterwards each of the bindings. The order is not important. If the bindings are properties, the vertices for them are created directly. If they are methods or computed properties, they are resolved by the \code{MethodCache} and the correct edges based on the binding type created. The above is done in the \code{addInit()} and \code{addBindings()} methods.

At this stage no vertices are created for the reads, writes, and calls properties of the resolved methods. 
This happens in the \code{addIndirectlyCalledMethods()} method, after all bindings and the init method have been resolved by taking all methods stored in the \code{MethodCache} and creating the appropriate vertices.

Lastly in the \code{addEdgesForLists} method additional edges will be added for the \textit{all} vertices of properties of elements inside lists.

\section{Scenario Generation}

% half a page, 1 page?
traversal
print to ui, but can ...

\ldots usage?
