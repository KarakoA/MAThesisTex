\section{State of the Art}
TODO
\subsection{TODO some papers}

\section{Interaction Diagrams}
\section{Scenario Testing}
Scenario testing, was originally introduced in \textcite{kaner2003power} and later as \textcite{kaner2013introduction}. The author defines scenarios as hypothetical stories, which aid a person in understanding a complex system or problem. Scenario tests are tests, which are based on such scenarios.  \parencite[1]{kaner2013introduction}
Further, \parencite[2-5]{kaner2003power} defines five characteristics, which make up a good scenario test as follows:
A Scenario test must be
\begin{itemize}
     \item based on a story - based on a description of how the program is being used
    \item motivating - stakeholders have interest in this test succeeding and would see to it's resolution
    \item credible - probable to happen in the real world
    \item complex - complex use, data or environment
    \item easy to evaluate - it should be easy to tell if the test succeded or failed based on the results 
\end{itemize}

\textcite{kaner2013introduction} describes the biggest advantages of scenario testing to be  - understanding and learning the product in early stages of development(1), connecting of testing and requirement documentations(2), exposing shortcomings in delivering of desired benefits(3), exploration of expert use of the program(4), expose requirement related issues(5).

\section{Behavior-Driven Development}
Behavior-Driven Development (BDD), pioneered by  \textcite{north2006behavior} is a software development
process , that combines principles from Test-Driven Development and Domain-Driven design \parencite{evans2004domain}.

Its main goal is to specify a system in terms of its functionality (i.e. it's behaviors) with a simple domain-specific language (DSL) making use of English-like sentences. This stimulates collaboration between developers and non-technical stakeholders and further results in a closer connection between acceptance criteria for a given function and matching tests used for its validation.

BDD splits a user story into multiple scenarios, each formulated in the form of \textit{Given}, \textit{When}, \textit{Then} statements, respectively specifying the prerequisite/context, event and outcomes of a scenario. 

[TODO] example here

At present ... there based on the division of behavior descriptions and behaviors. Such as Jest/Jasmine combine behavior descriptions and behaviors into one, whereas as Cucumber uses a DSL named Gherkin to specify the behavior descriptions and provides a set of tools to generate behaviors.
%[TODO example A vs B? ]


 \subsection{the other one(forgot name)}
 splitting into ...
\subsection{Gherkin Language}

\section{Model-View-ViewModel}
\label{sec:mvvm}
\gls{mvvm} is a design pattern, which helps in creating a clear separation between business and presentation logic and \gls{ui} of an application. \parencite[7-9]{microsoft_mvvm}

In \gls{mvvm} there are three core components - the view, model and view model. Those components are clearly separated from each other - the view is aware of the view model and the view model is aware of the model. However, this does not hold in reverse - the model is unaware of the view model and the view model is unaware of the view. 

\begin{figure}[H]
  \includegraphics[width=\textwidth]{images/mvvm.png}
   \caption{\gls{mvvm} design pattern overview, adapted from \parencite[7]{microsoft_mvvm}}
   \label{fig:mvvm}
 \end{figure}

\subsection{View}
The view is what the user sees. It is responsible for the structure, layout and appearance of the application.
\subsection{View-Model}
The view model implements event handlers and properties, to which the view can bind to. It also notifies the view of any changes to the underlying data. It defines the functionality, offered by the \gls{ui}, but the view determines how it is presented. 
\subsection{Model}
The model encapsulates the data of the application and validation its logic.


\section{Vue.js}

Vue.js \parencite{vuejs_gh} is a progressive front end framework for building user intefaces and single-page applications based on the \gls{mvvm} design pattern described in \ref{sec:mvvm} \parencite{vuejs_book} \parencite{vuejs_guide}.  

\subsection{Components}
At the core of Vue.js are components, which are small, self-contained, composable and often reusable custom elements. Almost any type of application can be represented as a tree of components \parencite{vuejs_guide}. 

In more concrete terms, a Vue.js component is a single file with the extension of \code{.vue}, which consists of a \code{template}, \code{script} and optional \code{style} part. The \code{template} is a HTML-based template, which can be parsed specification compliant browsers and HTML parsers. It can contain other components or html elements and is equivalent to the \textit{view} in \gls{mvvm}. 

The \textit{code} section of a Vue.js component includes the view-model of the component. It has a special json object \code{data}, which is equivalent to the \gls{mvvm} model. %TODO not so nicely written
The \code{script} part of a computed includes css-like styles.


data binding is a general technique that binds data sources from the provider and consumer together and synchronizes them.


\subsection{Reactivity}

%TODO this with own words here
% https://vuejs.org/v2/guide/reactivity.html

\dots enables data binding
\subsection{Directives}
Vue.js enables one way bindings(from source - data to target - component or html tag) via the \code{v-bind} (line X,Y) or \textit{moustache} syntax (line Z). 
Bindings can contain expressions (line X,Y). 

Two way binding can be achieved using the \textit{v-model} directive (line,X,Y,Z). 
Event handlers can be bound by the method name or also expressions.

%TODO vfor binding here

%TODO examples in code snippet image

\subsection{Data Binding}
Vue.js provides support for various forms of \gls{databinding} via a special syntax. Both the data and computed objects of a \code{Vue.js} component are reactive 


Via a special syntax
\code{Vue.js}
- one way
- two way
- event bindings
- inline expressions
- computed properties

\subsection{Vue.js directives}
\subsection{Structure of a Component}

(template, code etc.)

bindings two way, one way

g
- data
- computed properties

template part
code part
bindings


\section{ESLint}

ESLint \parencite{eslintMainPage} is a linting tool (linter) for ECMAScript/JavaScript. Linters are static code analysis tool, which can be used to flag and potentially automatically fix common code issues and enforce consistent code styling.


\subsection{Architecture}

At a very high level, ESLint consists of 
\begin{figure}[H]
    \includegraphics[width=\textwidth]{images/eslint_architecture.png}
     \caption{ESLint Architecture taken from \cite{eslintArchitecture}}
     \label{fig:eslintArchitecture}
   \end{figure}


\section{Rules}
At the core of ESLint are rules. Rules are extensible pieces of code, bundled as plugins, which can be used to verify various aspects of code. An example would be a rule, which checks for matching closing paranthesis. 
Each rule consists of a \code{metadata} object
and a \code{create} function. The metadata object includes metadata such as documentation strings, the type of the rule and whehter it is fixable or not.

Based on type, rules can be either \textit{suggestions}, \textit{problems} or \textit{layout}. Suggestions indicate some improvement, but are not required and would not cause the linting to fail. Problems on the other hand would result in a linting failure. Layouts are rules that care mainly about the formatting of code, such as whitespaces, semicolons, etc. 

If the fixable property is specified, it indicates that the errors reported by this rule can be automatically fixed. This can be applied via the \code{--fix} command line option. It has two possible values - \textit{code} or \textit{whitespace} indicating the type of fixes, that this rule would apply. For example in \glspl{ide} fixable \textit{code} errors would show a fix shortcut displayed next to them and \textit{whitespace} rules could be applied when saving the file.

The \code{create} function of rules takes as arguments a \code{context} and returns an object of methods which are called by ESLint for each node based on the \gls{visitor} pattern while traversing the \gls{ast}. ESLint provides a very powerful matching mechanism for specifying what nodes to match called selectors \parencite{eslintSelectors} inspired by \textcite{estoolsEsQuery}. 


TODO custom architecture image

TODO what are selectors

TODO what does context provide?

\subsection{AST Explorer}
An incredibly useful tool when working with \glspl{ast} is \gls{ast} Explorer, developed by \textcite{astexplorer_fkling2021Jan}. It enables the exploration of syntax tree generated by various parsers and also includes the vue-eslint-parser \parencite{eslint_vue_parser}

\subsection{ESTree AST}
By default ESLint uses the \parencite{eslintEspree} parser to parse JavaScript source code into an \gls{ast} as defined by ESTree specification \parencite{estreeASTSpec}. When Parsing \textit{.vue} files ESLint uses this parser for the code inside the \code{<script>} tag.
  
\subsection{ESLint Parser Vue AST}
In order to parse the \code{<template>} section of \textit{.vue} files, ESLint uses the vue-eslint-parser \parencite{eslint_vue_parser}. This parser outputs an  \gls{ast} compliant with their own  \gls{ast}specification, defined in \parencite{eslint_vue_parser_ast}.
